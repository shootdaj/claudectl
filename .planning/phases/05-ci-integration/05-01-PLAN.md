---
phase: 05-ci-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/ci.yml
  - package.json
autonomous: true

must_haves:
  truths:
    - "GitHub Actions runs tests via Docker Compose"
    - "Developer runs sandbox with sample data via npm script"
    - "Developer runs clean sandbox via npm script"
    - "Developer opens shell in container via npm script"
    - "CI and local use identical Docker environment"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "Docker-based CI workflow"
      contains: "docker compose run --rm test"
    - path: "package.json"
      provides: "DX npm scripts for sandbox modes"
      contains: "sandbox"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "docker-compose.yml"
      via: "docker compose run --rm test"
      pattern: "docker compose run --rm test"
    - from: "package.json scripts"
      to: "docker-compose.yml services"
      via: "docker compose run --rm"
      pattern: "docker compose run --rm (sandbox|sandbox-clean|sandbox-shell)"
---

<objective>
Configure CI to run tests via Docker Compose and add npm scripts for developer sandbox access.

Purpose: Ensure CI and local development use identical Docker environment, eliminating "works on my machine" issues. Provide convenient npm scripts for common sandbox operations.

Output: Updated CI workflow using Docker Compose, npm scripts for sandbox/sandbox:clean/sandbox:shell
</objective>

<execution_context>
@/Users/anshul/.claude/get-shit-done/workflows/execute-plan.md
@/Users/anshul/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ci-integration/05-RESEARCH.md
@docker-compose.yml
@.github/workflows/ci.yml
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CI workflow to use Docker Compose</name>
  <files>.github/workflows/ci.yml</files>
  <action>
Update the GitHub Actions CI workflow to run tests via Docker Compose:

1. Add `docker/setup-compose-action@v1` step after checkout
2. Replace the current test approach:
   - Keep typecheck running directly on runner (fast, deterministic - per research recommendation)
   - Replace `bun test` with `docker compose run --rm test`
3. Add cleanup step with `if: always()` that runs `docker compose down -v`

Key changes:
- Remove the "Install dependencies" step (Docker handles this)
- Keep "Setup Bun" and "Type check" for fast type checking
- Add Docker Compose setup step
- Run tests via Docker

Pattern from research:
```yaml
- name: Set up Docker Compose
  uses: docker/setup-compose-action@v1

- name: Run tests
  run: docker compose run --rm test

- name: Cleanup
  if: always()
  run: docker compose down -v
```

Do NOT:
- Remove typecheck step (keep it for speed)
- Use `docker-compose` (hyphenated) - deprecated
- Skip `--rm` flag (leaves container debris)
  </action>
  <verify>
Read the updated `.github/workflows/ci.yml` and confirm:
1. `docker/setup-compose-action@v1` is present
2. `docker compose run --rm test` is used for tests
3. Cleanup step exists with `if: always()`
4. Typecheck step is preserved
  </verify>
  <done>CI workflow runs tests via Docker Compose while keeping fast typecheck on runner</done>
</task>

<task type="auto">
  <name>Task 2: Add npm scripts for sandbox developer experience</name>
  <files>package.json</files>
  <action>
Add npm scripts for convenient sandbox access:

1. Add `sandbox` script: `docker compose run --rm sandbox`
   - Starts sandbox with sample data (TUI mode)
   - Maps to existing `sandbox` service in docker-compose.yml

2. Add `sandbox:clean` script: `docker compose run --rm sandbox-clean`
   - Starts clean sandbox with tmpfs (empty state)
   - Maps to existing `sandbox-clean` service

3. Add `sandbox:shell` script: `docker compose run --rm sandbox-shell`
   - Opens bash shell in container
   - Maps to existing `sandbox-shell` service

Add these in the scripts section after the existing test scripts:
```json
"sandbox": "docker compose run --rm sandbox",
"sandbox:clean": "docker compose run --rm sandbox-clean",
"sandbox:shell": "docker compose run --rm sandbox-shell"
```

Do NOT:
- Add pre/post hooks (keep simple per research - document rebuild separately)
- Remove existing scripts
- Use `docker-compose` (hyphenated)
  </action>
  <verify>
Run `bun run` (no args) to list scripts and confirm:
1. `sandbox` script is present
2. `sandbox:clean` script is present
3. `sandbox:shell` script is present
All existing scripts are preserved.
  </verify>
  <done>Developers can run `bun run sandbox`, `bun run sandbox:clean`, `bun run sandbox:shell`</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **CI workflow validation:**
   ```bash
   cat .github/workflows/ci.yml | grep -E "(docker compose|setup-compose)"
   ```
   Should show Docker Compose setup and run commands.

2. **npm scripts validation:**
   ```bash
   cat package.json | grep -E '"sandbox'
   ```
   Should show all three sandbox scripts.

3. **Scripts are runnable (dry run check):**
   ```bash
   # Verify docker-compose.yml services exist for each script
   docker compose config --services | grep -E "(sandbox|sandbox-clean|sandbox-shell)"
   ```
   Should list all three services.
</verification>

<success_criteria>
- [ ] CI workflow uses `docker/setup-compose-action@v1`
- [ ] CI workflow runs `docker compose run --rm test` for tests
- [ ] CI workflow has cleanup step with `if: always()`
- [ ] `bun run sandbox` command is available
- [ ] `bun run sandbox:clean` command is available
- [ ] `bun run sandbox:shell` command is available
- [ ] All existing scripts remain functional
</success_criteria>

<output>
After completion, create `.planning/phases/05-ci-integration/05-01-SUMMARY.md`
</output>
